<?xml version='1.0' encoding='UTF-8'?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0"><channel><title>晓吹的摆烂博客</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io</link><description>This is a subtitle.</description><copyright>晓吹的摆烂博客</copyright><docs>http://www.rssboard.org/rss-specification</docs><generator>python-feedgen</generator><image><url>https://avatars.githubusercontent.com/u/97146342?v=4</url><title>avatar</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io</link></image><lastBuildDate>Tue, 17 Dec 2024 02:13:30 +0000</lastBuildDate><managingEditor>晓吹的摆烂博客</managingEditor><ttl>60</ttl><webMaster>晓吹的摆烂博客</webMaster><item><title>C语言猜数字小游戏</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/C-yu-yan-cai-shu-zi-xiao-you-xi.html</link><description>```c&#13;
#include &lt;stdio.h&gt;&#13;
&#13;
int correctA(char n[], char guess[]) //判断位置正确的个数 &#13;
{&#13;
	int count = 0, i;&#13;
	for (i = 0; i &lt; 4; i++)&#13;
	{&#13;
		if (n[i] == guess[i])&#13;
		{&#13;
			count++;&#13;
		}&#13;
	}&#13;
	return count;&#13;
}&#13;
&#13;
int correctB(char n[], char guess[]) // 判断数字正确的个数 &#13;
{&#13;
	int count = 0, i, j;&#13;
	for (i = 0; i &lt; 4; i++)&#13;
	{&#13;
		for (j = 0; j &lt; 4; j ++)&#13;
		{&#13;
			if (guess[j] == n[i])&#13;
			{&#13;
				count++;&#13;
			}&#13;
		}&#13;
	}&#13;
	return count - correctA(n, guess);&#13;
}&#13;
int play(char n[])&#13;
{&#13;
	char guess[5];&#13;
	gets(guess);&#13;
	printf('%dA%dB\n', correctA(n, guess), correctB(n, guess));&#13;
	if (correctA(n, guess) == 4)&#13;
	{&#13;
		printf('You win!\n');&#13;
		return 1;&#13;
	}else&#13;
	{&#13;
		return 0;&#13;
	}&#13;
}&#13;
char* random(char str[])&#13;
{&#13;
	int n;&#13;
	srand((unsigned)time(NULL));&#13;
	n = rand() % 9999 + 1000; // 生成在1000-9999之间的随机数&#13;
	&#13;
	// 拆分 &#13;
	int n1, n2, n3, n4;&#13;
	n1 = n / 1000;&#13;
	n2 = n / 100 - n1 * 10;&#13;
	n3 = n / 10 - n1 * 100 - n2 * 10;&#13;
	n4 = n % 10;&#13;
	&#13;
	// 转成字符数组&#13;
	int i;&#13;
	str[0] = n1 + '0';&#13;
	str[1] = n2 + '0';&#13;
	str[2] = n3 + '0';&#13;
	str[3] = n4 + '0';&#13;
	str[4] = '\0';&#13;
	printf('Generated random number is %s\n', str);&#13;
	return str;&#13;
}&#13;
int main()&#13;
{&#13;
	char str[5];&#13;
	char n[5];&#13;
	strcpy(n, random(str));&#13;
	int i, count = 0;&#13;
	while (play(n) != 1)&#13;
	{&#13;
		count++;&#13;
		printf('You still have %d chances.\n', 7 - count);&#13;
		if (count &gt; 6) break;&#13;
	}&#13;
}&#13;
``` 。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/C-yu-yan-cai-shu-zi-xiao-you-xi.html</guid><pubDate>Tue, 17 Dec 2024 01:45:40 +0000</pubDate></item><item><title>Unity 基本移动代码</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/Unity%20-ji-ben-yi-dong-dai-ma.html</link><description>```c#&#13;
using System;&#13;
using System.Collections;&#13;
using System.Collections.Generic;&#13;
using System.Runtime.InteropServices.ComTypes;&#13;
using UnityEditor.Rendering;&#13;
using UnityEngine;&#13;
using UnityEngine.InputSystem;&#13;
public class PlayerController : MonoBehaviour&#13;
{&#13;
    public PlayerInputControl inputControl;  // 用于存储玩家的输入控制器&#13;
    private Rigidbody2D rb; // 用于存储玩家的刚体组件，用于物理运动&#13;
    private Vector2 inputDirection; // 用于存储玩家输入的方向向量&#13;
    private CapsuleCollider2D coll;&#13;
    private PhysicsCheck physicsCheck; //隔壁的PhysicsCheck类&#13;
&#13;
    private Vector2 originalOffset;&#13;
    private Vector2 originalSize;&#13;
    [Header('状态显示')]&#13;
    public bool isCrouch;&#13;
&#13;
    [Header('基本参数')]&#13;
    public float speed; // 玩家移动速度&#13;
    private float runSpeed;&#13;
    private float walkSpeed =&gt; speed / 3f; // lambda表达式&#13;
    public float jumpForce; // 玩家跳跃受力&#13;
&#13;
    void Awake() // Awake(): 在游戏对象创建时调用&#13;
    {&#13;
        physicsCheck = GetComponent&lt;PhysicsCheck&gt;(); // 获取PhysicsCheck的数据&#13;
        rb = GetComponent&lt;Rigidbody2D&gt;(); // 获取Rigidbody2D的数据&#13;
        coll = GetComponent&lt;CapsuleCollider2D&gt;(); // 获取CapsuleCollider2D数据&#13;
&#13;
        originalOffset = coll.offset; // 获取CapsuleCollider2D.offset初始值&#13;
        originalSize = coll.size; // 获取CapsuleCollider2D.size初始值&#13;
&#13;
        inputControl = new PlayerInputControl(); //实例化PlayerInputControl于inputControl&#13;
&#13;
        inputControl.Gameplay.Jump.started += Jump; // 订阅事件Jump.started，每次事件触发启动Jump（）&#13;
&#13;
        #region 强制步行&#13;
        runSpeed = speed;&#13;
        inputControl.Gameplay.WalkButton.performed += ctx =&gt; // performed: 持续按下&#13;
        {&#13;
            if (physicsCheck.isGround) // 若角色在地面上时按下Alt键&#13;
            {&#13;
                speed = walkSpeed;&#13;
            }&#13;
        };&#13;
        inputControl.Gameplay.WalkButton.canceled += ctx =&gt; // canceled: 取消按下&#13;
        {&#13;
            if (physicsCheck.isGround)&#13;
            {&#13;
            speed = runSpeed;&#13;
            }&#13;
        };&#13;
        #endregion&#13;
    }&#13;
    void OnEnable() // OnEnable(): 启用inputControl时调用&#13;
    {&#13;
        inputControl.Enable(); // 启用输入控制&#13;
    }&#13;
    void OnDisable() // OnDisable(): 禁用inputControl时调用&#13;
    {&#13;
        inputControl.Disable(); // 禁用输入控制&#13;
    }&#13;
    void Update() // Update(): 每帧调用&#13;
    {&#13;
        inputDirection = inputControl.Gameplay.Move.ReadValue&lt;Vector2&gt;();&#13;
    }&#13;
    void FixedUpdate() // FixedUpdate(): 每固定帧调用&#13;
    {&#13;
        Move();&#13;
    }&#13;
&#13;
    private void Move() // 定义移动方法&#13;
    {&#13;
        #region 人物移动&#13;
        if (!isCrouch)&#13;
        {&#13;
        rb.linearVelocity = new Vector2(speed * inputDirection.x, rb.linearVelocity.y); // 人物移动 velocity：速度 isWalk模拟轻推摇杆&#13;
        }&#13;
        // 实现人物朝向改变&#13;
        int faceDir = (int)transform.localScale.x; // 获取人物朝向&#13;
        if (inputDirection.x &gt; 0 &amp;&amp; faceDir != 1) // 改变人物朝向&#13;
        {&#13;
            transform.localScale = new Vector3(1, 1, 1);&#13;
        }&#13;
        else if (inputDirection.x &lt; 0 &amp;&amp; faceDir != -1)&#13;
        {&#13;
            transform.localScale = new Vector3(-1, 1, 1);&#13;
        }&#13;
        #endregion&#13;
&#13;
        isCrouch = inputDirection.y &lt; -0.5f &amp;&amp; physicsCheck.isGround;// 下蹲&#13;
        if (isCrouch) // 碰撞箱缩小&#13;
        {&#13;
            coll.offset = new Vector2(-0.05f, 0.75f);&#13;
            coll.size = new Vector2(0.66f, 1.5f);&#13;
        }&#13;
        else&#13;
        {&#13;
            coll.size = originalSize;&#13;
            coll.offset = originalOffset;&#13;
        }&#13;
    }&#13;
    private void Jump(InputAction.CallbackContext context) // 定义跳跃方法&#13;
    {&#13;
        if(physicsCheck.isGround)&#13;
        {&#13;
            rb.AddForce(transform.up * jumpForce, ForceMode2D.Impulse); // Rigitbody2D.AddForce(Vector2 force, ForceMode2D mode) transform.up为坐标轴正上方向，值通常为1。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/Unity%20-ji-ben-yi-dong-dai-ma.html</guid><pubDate>Wed, 11 Dec 2024 15:09:30 +0000</pubDate></item><item><title>C语言求解八皇后问题</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/C-yu-yan-qiu-jie-ba-huang-hou-wen-ti.html</link><description>利用回溯法&#13;
```c&#13;
#include &lt;stdio.h&gt;&#13;
int place[8] = {0};  //保存每行皇后位置&#13;
int flag[8] = {0}; // 列标记&#13;
int d1[16] = {0}; // 对角线1&#13;
int d2[16] = {0}; // 对角线2&#13;
int count = 0;&#13;
&#13;
void place_queen(int x, int y) {&#13;
    place[x] = y;&#13;
    flag[y] = 1;&#13;
    d1[x - y + 7] = 1; // 主对角线索引&#13;
    d2[x + y] = 1;     // 副对角线索引&#13;
}&#13;
&#13;
void remove_queen(int x, int y) {&#13;
    flag[y] = 0;&#13;
    d1[x - y + 7] = 0;&#13;
    d2[x + y] = 0;&#13;
}&#13;
&#13;
void print() { // 打印皇后位置&#13;
    int i, j;&#13;
    int table[8][8] = {0};&#13;
    count++; // 计算解的个数&#13;
    printf('No. %d\n', count);&#13;
    for (i = 0; i &lt; 8; i++) {&#13;
        table[i][place[i]] = 1; // 将place数组转为二维数组&#13;
    }&#13;
    for (i = 0; i &lt; 8; i++) {&#13;
        for (j = 0; j &lt; 8; j++) {&#13;
            printf('%d ', table[i][j]);&#13;
        }&#13;
        printf('\n');&#13;
    }&#13;
    printf('&lt;================&gt;\n');&#13;
}&#13;
&#13;
void generation(int x) {&#13;
    int y;&#13;
    for (y = 0; y &lt; 8; y++) {&#13;
        // 判断是否冲突&#13;
        if (!(flag[y] || d1[x - y + 7] || d2[y + x])) {&#13;
            place_queen(x, y); // 放置皇后&#13;
            if (x &lt; 7) {&#13;
                generation(x + 1); // 递归&#13;
            } else {&#13;
                print(); // 放完所有的皇后&#13;
            }&#13;
            remove_queen(x, y); // 回溯&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
int main() {&#13;
    generation(0); // 从第0行开始放置&#13;
}&#13;
``` 。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/C-yu-yan-qiu-jie-ba-huang-hou-wen-ti.html</guid><pubDate>Wed, 11 Dec 2024 06:40:10 +0000</pubDate></item><item><title>解决C语言函数调用 warning: implicit declaration of function ‘a‘</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/jie-jue-C-yu-yan-han-shu-diao-yong-%20warning-%20implicit%20declaration%20of%20function%20%E2%80%98a%E2%80%98.html</link><description>&gt; 本文截取自 https://blog.csdn.net/xiaobai729/article/details/127138269&#13;
&#13;
一般常见原因是先写了主函数，然后在主函数中调用其他函数。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/jie-jue-C-yu-yan-han-shu-diao-yong-%20warning-%20implicit%20declaration%20of%20function%20%E2%80%98a%E2%80%98.html</guid><pubDate>Tue, 10 Dec 2024 09:04:28 +0000</pubDate></item><item><title>C语言环境设置 | Windows 安装编译器和 VS Code</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/C-yu-yan-huan-jing-she-zhi-%20-%20Windows%20-an-zhuang-bian-yi-qi-he-%20VS%20Code.html</link><description>&gt; 本文截取自 https://www.bilibili.com/video/BV112z3YUEmU&#13;
# 下载 C 编译器&#13;
为了能在 Windows 上使用 GCC，我们可以下载 MSYS2，它包含了 GCC 编译器的 Windows 版本。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/C-yu-yan-huan-jing-she-zhi-%20-%20Windows%20-an-zhuang-bian-yi-qi-he-%20VS%20Code.html</guid><pubDate>Tue, 10 Dec 2024 08:59:02 +0000</pubDate></item><item><title>B站注册时间查询</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/B-zhan-zhu-ce-shi-jian-cha-xun.html</link><description>1. 网页上登陆自己的b站账号。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/B-zhan-zhu-ce-shi-jian-cha-xun.html</guid><pubDate>Tue, 10 Dec 2024 06:44:47 +0000</pubDate></item><item><title>Hello, world!</title><link>https://XiaoCoaiX.github.io/xcsweb.github.io/post/Hello%2C%20world%21.html</link><description># test&#13;
这是一个测试页面。</description><guid isPermaLink="true">https://XiaoCoaiX.github.io/xcsweb.github.io/post/Hello%2C%20world%21.html</guid><pubDate>Tue, 10 Dec 2024 06:19:04 +0000</pubDate></item></channel></rss>